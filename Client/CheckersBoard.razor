@using OnlineCheckers.Client.Data
<div>
    @(isWhiteTurn? "Whites' turn" : "Blacks' turn")
</div>
@for (int i = 0; i < Constants.BOARD_SIZE; i++)
{
    int auxI = i;
    <div class="row">
        @for (int j = 0; j < Constants.BOARD_SIZE; j++)
        {
            int auxJ = j;
            var checker = blackCheckers.FirstOrDefault(n => n.Column == j && n.Row == i);
            if (checker == null) checker = whiteCheckers.FirstOrDefault(n => n.Column == j && n.Row == i);
            
            bool isPossibleMove = movePossibilities.Contains((auxI, auxJ));

            <div class="cell @(isPossibleMove ? "active" : "")" @onclick="() => { MoveChecker(auxI, auxJ); }">
                @if (checker != null)
                {
                    <div class="checker @checker.Color @(checker == activeChecker ? "active" : "")" @onclick="()=> { CheckerPieceClicked(checker); }">
                        <div>@(checker.Diretion == CheckerDirection.Both ? "♕" : "")</div>
                    </div>
                }
            </div>
        }
    </div>
}

@code {
    bool isWhiteTurn = true;
    List<Checker> blackCheckers = new List<Checker>();
    List<Checker> whiteCheckers = new List<Checker>();
    Checker activeChecker = null;

    List<(int row, int column)> movePossibilities = new List<(int, int)>();

    protected override void OnInitialized()
    {
        base.OnInitialized();
        GeneratePieces();

    }

    protected void CheckerPieceClicked(Checker checker)
    {
        if (isWhiteTurn && checker.Color == Constants.BLACK_CHECKER_COLOR_NAME)
            return;
        if (!isWhiteTurn && checker.Color == Constants.WHITE_CHECKER_COLOR_NAME)
            return;

        SetActiveChecker(checker); 
        GeneratePossibleMoves();    
    }

    protected void SetActiveChecker(Checker checker)
    {
        activeChecker = checker;
    }

    protected void GeneratePossibleMoves()
    {
        ClearPossibilities();

        if(activeChecker != null)
        {
            List<int> rowPossibilities = new List<int>();

            if(activeChecker.Diretion == CheckerDirection.Down || activeChecker.Diretion == CheckerDirection.Both)
            {
                rowPossibilities.Add(activeChecker.Row + 1);
            }

            if(activeChecker.Diretion == CheckerDirection.Up || activeChecker.Diretion == CheckerDirection.Both)
            {
                rowPossibilities.Add(activeChecker.Row - 1);
            }

            foreach (int row in rowPossibilities)
            {
                EvaluateMove(row, activeChecker.Column - 1);
                EvaluateMove(row, activeChecker.Column + 1);
            }
        }
    }

    protected void EvaluateMove(int row, int column, bool isFirstTime = true)
    {
        var blackChecker = blackCheckers.FirstOrDefault(n => n.Row == row && n.Column == column);
        var whiteChecker = whiteCheckers.FirstOrDefault(n => n.Row == row && n.Column == column);

        if(whiteChecker ==  null && blackChecker == null)
        {
            movePossibilities.Add((row, column));
        }
        else if(isFirstTime)
        {
            //Evaluating jump over possibility
            if((isWhiteTurn && blackChecker != null) ||
            (!isWhiteTurn && whiteChecker != null))
            {
                int columnGap = column - activeChecker.Column;

                int rowGap = row - activeChecker.Row;

                EvaluateMove(row + rowGap, column + columnGap, false);
            }
        }

    }

    protected void ClearPossibilities()
    {    
        movePossibilities.Clear();
    }

    void MoveChecker(int row, int column)
    {
        bool isPossibleMove = movePossibilities.Contains((row, column));
        if (!isPossibleMove) return;

        if((activeChecker.Row == 0 && activeChecker.Color == Constants.WHITE_CHECKER_COLOR_NAME) || 
        (activeChecker.Row == (Constants.BOARD_SIZE - 1) && activeChecker.Color == Constants.BLACK_CHECKER_COLOR_NAME))
        {
            activeChecker.Diretion = CheckerDirection.Both;
        }

        CheckForCheckerTaken(row, column);

        activeChecker.Column = column;
        activeChecker.Row = row;

        activeChecker = null;
        ClearPossibilities();
        ChangeTurn();
    }

    protected void CheckForCheckerTaken(int row, int column)
    {
        Console.WriteLine("Evaluating if checker was taken");

        if(Math.Abs(activeChecker.Column - column) == 2)
        {
            int jumpedColumn = (activeChecker.Column + column) / 2;
            int jumpedRow = (activeChecker.Row + row) / 2;

            Checker? takenChecker = null;
            if (isWhiteTurn)
            {
                takenChecker = blackCheckers.FirstOrDefault(n => n.Column == jumpedColumn && n.Row == jumpedRow);
                if (takenChecker != null) blackCheckers.Remove(takenChecker);
            }
            else
            {
                takenChecker = whiteCheckers.FirstOrDefault(n => n.Column == jumpedColumn && n.Row == jumpedRow);
                foreach (var whiteChecker in whiteCheckers)
                {
                    Console.WriteLine(whiteChecker.Row + "  | " + whiteChecker.Column);
                }
                if (takenChecker != null) whiteCheckers.Remove(takenChecker);
                
            }
        }
    }

    protected void ChangeTurn()
    {
        isWhiteTurn = !isWhiteTurn;
    }

    protected void GeneratePieces()
    {
        for (int i = 0; i < 3; i++)
        {
            for (int j = (i + 1) % 2; j < Constants.BOARD_SIZE; j+=2)
            {
                blackCheckers.Add(new Checker()
                    {
                        Column = j,
                        Row = i,
                        Diretion = CheckerDirection.Down,
                        Color = Constants.BLACK_CHECKER_COLOR_NAME
                    });
            }
        }
        
        for (int i = 5; i < 8; i++)
        {
            for (int j = (i + 1) % 2; j < Constants.BOARD_SIZE; j+=2)
            {
                whiteCheckers.Add(new Checker()
                    {
                        Column = j,
                        Row = i,
                        Diretion = CheckerDirection.Up,
                        Color = Constants.WHITE_CHECKER_COLOR_NAME
                    });
            }
        }
        
    }
}
